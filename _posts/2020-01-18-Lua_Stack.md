---
layout:     post
title:      Lua Stack
subtitle:   Lua源码分析——Stack
date:       2019-12-28
author:     jiuguang
catalog: true
tags:
    - lua源码分析
---

## 前言

Lua 栈是LuaState的核心，它维护了Lua函数调用的上下文信息，充当C与Lua通信的”桥梁“，本文介绍Lua Stack结构，核心相关function实现。

### Lua Stack内存结构

LuaState 是一个Luavm的实例，不同的LuaState拥有不同的调用栈，而其中的调用栈实现就是：Lua Stack。Stack的实现是一个TValue数组，索引从0开始递增，每次有push或者相关可能增大Lua栈的操作，就会去检查是否需要栈扩展，确保能保存即将发生的上下文信息。LuaState中有几个核心的成员，记录着和栈相关的数据:

+ StkId stack： 栈数组的base指针
+ StkId top; 栈的top指针，指向数组最后一个元素的下一个地址
+ StkId stack_last: 当栈增长时，top最终指向栈的最高点，stack_last指向最新的未被使用的位置
+ int stacksize： 栈的size

```
typedef TValue *StkId;  /* index to stack elements */

struct lua_State {
  CommonHeader;
  unsigned short nci;  /* number of items in 'ci' list */
  lu_byte status;
  StkId top;  /* first free slot in the stack */
  global_State *l_G;
  CallInfo *ci;  /* call info for current function */
  const Instruction *oldpc;  /* last pc traced */
  StkId stack_last;  /* last free slot in the stack */
  StkId stack;  /* stack base */
  UpVal *openupval;  /* list of open upvalues in this stack */
  GCObject *gclist;
  struct lua_State *twups;  /* list of threads with open upvalues */
  struct lua_longjmp *errorJmp;  /* current error recover point */
  CallInfo base_ci;  /* CallInfo for first level (C calling Lua) */
  volatile lua_Hook hook;
  ptrdiff_t errfunc;  /* current error handling function (stack index) */
  int stacksize;
  int basehookcount;
  int hookcount;
  unsigned short nny;  /* number of non-yieldable calls in stack */
  unsigned short nCcalls;  /* number of nested C calls */
  l_signalT hookmask;
  lu_byte allowhook;
};

```

标准栈的读写，应该只提供pop/push，但Lua栈实际提供了基于index访问的实现，index分为正/负：

+ index > 0 : 从栈底向上索引，即 lua_State.stack + index
+ index < 0 : 从栈顶往下索引， 即 lua_State.top + index